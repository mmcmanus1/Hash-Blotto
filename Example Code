import Pkg;

# Pkg.add("BenchmarkTools"); Pkg.add("DataStructures"); Pkg.add("PlutoTeachingTools"); Pkg.add("PlutoUI"); Pkg.add("SparseArrays"); 

# using BenchmarkTools
# using DataStructures
# using PlutoTeachingTools
# using PlutoUI
using SparseArrays
using HashCode2014

city = read_city()
allowedTime, n, init_j = city.total_duration, city.nb_cars, city.starting_junction

function get_edge_dictionary(city)
    """
    A helper function that extracts a dictionary mapping adjacent edges. Particularly:
    input: A city object
    output: Dict(junctions .=> (possible_neighbor, duration, distance))
    """
    city_streets = city.streets
    edges = Dict()
    for edge in city_streets
        A, B, time, dist = edge.endpointA, edge.endpointB, edge.duration, edge.distance
        if A in keys(edges)
            push!(edges[A], (B, time, dist))
        else
            edges[A] = [(B, time, dist)] # Create a dict with A goes to B, time, distance
        end
        if edge.bidirectional
            if B in keys(edges)
                push!(edges[B], (A, time, dist))
            else
                edges[B] = [(A, time, dist)]
            end
        end
    end
    return edges
end

edges = get_edge_dictionary(city)

function greedy(graph, start)
    """
    A greedy single agent walk.
    Input a graph, and a start node.
    Continue until you run out of time by greedily choosing 
    the untraversed adjacent edge with maximum distance.
    If none-such exist: perform a random walk until encountering one, or until time runs out. 
    """
    time, visited, greedy_path = 0, [], []
    outneighbors = get_outneighbors(g, junction, t)
    while length(outneighbors) != 0
        unvisited_neighbors = get_unvisited(v, visited)
        if unvisited_neighbors
            pass # Check the max length unvisited one.
            # If no more possible 
        else
            # next explored is (junction, time, distance)
            next_explored = rand(outneighbors) # Should maybe weight by time in future
            time += next_explored[2]
            push!(visited, next_explored[1])
            push!(greedy_path, next_explored[1])
        end
        outneighbors = get_outneighbors(g, u, t)
    end
    return greedy_path
end

nb_vertices(edge_dict) = length(keys(edge_dict))

function get_unvisited(list, visited)
    f(x) = !(x in visited)
    x = filter(f, list)
    return x
end

# function edge_weight(g::ListGraph, u, v)
# 	for (x, y, w) in g.edges
# 		if (x, y) == (u, v)
# 			return w
# 		end
# 	end
# end

function get_outneighbors_and_distances(g, junction, t, allowedTime)
    """
    Get the outneighbors of an edge and the corresponding distance u
     given a time constraint t.
    Returns the empty array if none are possible
    """
    # Dict(junctions .=> (possible_neighbor, duration, distance))
    mapping = g[junction]
    zipped = [neighbor for neighbor in mapping if t + neighbor[2] < allowedTime]
    return zipped
    # if length(zipped) == 0
    #     return []
    # end
    # outneighbors, distances = collect(zip(zipped...))
    # return outneighbors, distances
    # Commented is a possible different output, if desired
end

print(get_outneighbors_and_distances(edges, 8660, 10, 0))
print(get_outneighbors_and_distances(edges, 8660, 10, 10000))