import Pkg;

# Pkg.add("BenchmarkTools"); Pkg.add("DataStructures"); Pkg.add("PlutoTeachingTools"); Pkg.add("PlutoUI"); Pkg.add("SparseArrays"); 

# using BenchmarkTools
# using DataStructures
# using PlutoTeachingTools
# using PlutoUI
using SparseArrays
using HashCode2014

city = read_city()
allowedTime, n, init_j = city.total_duration, city.nb_cars, city.starting_junction

function get_edge_dictionary(city)
    """
    A helper function that extracts a dictionary mapping adjacent edges. Particularly:
    input: A city object
    output: Dict(junctions .=> (possible_neighbor, duration, distance))
    """
    city_streets = city.streets
    edges = Dict()
    for edge in city_streets
        A, B, time, dist = edge.endpointA, edge.endpointB, edge.duration, edge.distance
        if A in keys(edges)
            push!(edges[A], (B, time, dist))
        else
            edges[A] = [(B, time, dist)] # Create a dict with A goes to B, time, distance
        end
        if edge.bidirectional
            if B in keys(edges)
                push!(edges[B], (A, time, dist))
            else
                edges[B] = [(A, time, dist)]
            end
        end
    end
    return edges
end

edges = get_edge_dictionary(city)

function greedy(graph, start)
    """
    A greedy single agent walk.
    Input a graph, and a start node.
    Continue until you run out of time by greedily choosing 
    the untraversed adjacent edge with maximum distance.
    If none-such exist: perform a random walk until encountering one, or until time runs out. 
    """
    dist = fill(Inf, nb_vertices(graph))  # here
	queue = [(start, 0)]
    visited = []
	while !isempty(queue)
        u, dist[u] = queue[1]
        unvisited_neighbor = get_unvisited(v, visited)
        if unvisited_neighbor
            pass
        else
            rand(outneighbors(graph, u) )
        end
    end
    return dist
end

nb_vertices(edge_dict) = length(keys(edge_dict))

function get_unvisited(list, visited)
    f(x) = !(x in visited)
    x = filter(f, list)
    return x
end

get_unvisited([1,2,3], [3,4])
# function edge_weight(g::ListGraph, u, v)
# 	for (x, y, w) in g.edges
# 		if (x, y) == (u, v)
# 			return w
# 		end
# 	end
# end

# function outneighbors(g::ListGraph, u)
# 	out = Int[]
# 	for (x, y, w) in g.edges
# 		if x == u
# 			push!(out, y)
# 		end
# 	end
# 	return out
# end