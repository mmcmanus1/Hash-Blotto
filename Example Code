import Pkg;

# Pkg.add("BenchmarkTools"); Pkg.add("DataStructures"); Pkg.add("PlutoTeachingTools"); Pkg.add("PlutoUI"); Pkg.add("SparseArrays"); 

# using BenchmarkTools
# using DataStructures
# using PlutoTeachingTools
# using PlutoUI
using SparseArrays
using HashCode2014

city = read_city()
allowedTime, n, init_j = city.total_duration, city.nb_cars, city.starting_junction

function get_edge_dictionary(city)
    """
    A helper function that extracts a dictionary mapping adjacent edges. Particularly:
    input: A city object
    output: Dict(junctions .=> (possible_neighbor, duration, distance))
    """
    city_streets = city.streets
    edges = Dict()
    for edge in city_streets
        A, B, time, dist = edge.endpointA, edge.endpointB, edge.duration, edge.distance
        if A in keys(edges)
            push!(edges[A], (B, time, dist))
        else
            edges[A] = [(B, time, dist)] # Create a dict with A goes to B, time, distance
        end
        if edge.bidirectional
            if B in keys(edges)
                push!(edges[B], (A, time, dist))
            else
                edges[B] = [(A, time, dist)]
            end
        end
    end
    return edges
end

edges = get_edge_dictionary(city)

function greedy(graph, start)
    """
    A greedy single agent walk.
    Input a graph, and a start node.
    Continue until you run out of time by greedily choosing 
    the untraversed adjacent edge with maximum distance.
    If none-such exist: perform a random walk until encountering one, or until time runs out. 
    """
	queue = [(start, 0)]
    time, visited, greedy_path = 0, [], []
    outneighbors = get_outneighbors(g, junction, t)
	# while !isempty(queue)
    while outneighbors
        unvisited_neighbors = get_unvisited(v, visited)
        if unvisited_neighbors
            pass # Check the max length unvisited one.
            # If no more possible 
        else
            rand(outneighbors(graph, u))
        end
        outneighbors = get_outneighbors(g, u, t)
    end
    return dist
end

nb_vertices(edge_dict) = length(keys(edge_dict))

function get_unvisited(list, visited)
    f(x) = !(x in visited)
    x = filter(f, list)
    return x
end

# function edge_weight(g::ListGraph, u, v)
# 	for (x, y, w) in g.edges
# 		if (x, y) == (u, v)
# 			return w
# 		end
# 	end
# end

function get_outneighbors_and_distances(g, junction, t, allowedTime)
    """
    Get the outneighbors of an edge and the corresponding distance u
     given a time constraint t.
    Returns the empty array if none are possible
    """
    # Dict(junctions .=> (possible_neighbor, duration, distance))
    mapping = g[junction]
    zipped = [(neighbor[1], neighbor[3]) for neighbor in mapping if t + neighbor[2] < allowedTime]
    if length(zipped) == 0
        return []
    end
    outneighbors, distances = collect(zip(zipped...))
    return outneighbors, distances
end

print(get_outneighbors_and_distances(edges, 8660, 10, 0))